CHANGES TO BE DONE IN SOC:
1. When creating Flat:
    when wings get created i need to add user with that flat name:
        i. flat name.
        ii. flat name + member name (unique name to make it as user name).
        iii. Example:
            Flat_id: A-WING-1
            Name: AWING1FAREEN

2. For Flat Details -> on view -> flat_status is not fetching from serializers
3. COUNTRY STATE API
4. SOME ISSUE IN COST CENTER MODAL

Bug fixes:
DropDown value not getting
history accordian(show date to date)
view file on edit
in table show just file name
In meetings edit show attendance
at the time of add or update give toastr and page refresh
change all the table heading
add nominees should come only when required
1. Add vehicle - doc not getting add
2. sweet alert not working
3. make pan and aadhar unitque

ADD FEATURES LATER:
1. Login
2. Authentication/Authorization (login)
3. Mobile app
4. Delete functionality for all the


========================================ACCOUNTS============================================================

1. Group Creation:
Sub group -> parent(Assets)
Under group -> child (Fixed Assets)
Group Name -> sub child (Computer)


IN VOUCHER CREATION

Against Refrence:
Voucher number:
amount:

1. Journal voucher - should have all the created vouchers - debit and credit.
2. Sales/Income - fetch will be in receipt.
3. Purchase/Expense - fetch will be in payment.



==================================== ************ ===================================================
1. Can more than one bank be primary.

=================================== ********* =====================================================
                                    PRIORITY


IN voucher creation on save 4 actions are getting performed:
1. save the voucher itself data.
2. create general entry for all those ledgers.
3. calculation of debit and credit amount to show running balance.
4. show that running balance on balance sheet.



Either show 2 entries for tds payable onw ith dr and one with cr.





TEST CASES:
case 1:
dr
cr


case 2: NOT
dr
cr
cr


case 3:
cr
dr
dr


case 4:
dr
dr
dr
cr
cr
cr


case 5:
dr
cr
cr
cr



======================================================================================
FOR BALANCE AMT:

1. opitimize code,
2. apply rule.
3. calculate amt:
    if amt directly,
    if amount is Dr +, Cr -, then
    cr = -5000
    dr = +6000
    then take amt directly, like
    - 5000 + 6000





===============================running balance in p & l===============================================
when we select the date filter from p and l date DropDown, it should show the running balance of that date:
for example i have GL entries as:

2024-08-11	HDFC Acc.	Nitesh	expenses_voucher	        1		5000	                5000
2024-08-10	HDFC Acc.	Zaco Info Tech	expenses_voucher	1	    5000		            10000
2024-08-09	HDFC Acc.	Taori Marketing	expenses_voucher	1	        		8000        2000
2024-08-09	HDFC Acc.	Sameer	expenses_voucher	        1		1000	                3000


i made filter date as "2024-08-09" i should get below amt, i.e 7000 and not above 3000:
2024-08-09	HDFC Acc.	Taori Marketing	expenses_voucher	1	        		8000        8000
2024-08-09	HDFC Acc.	Sameer	expenses_voucher	        1		1000	                7000



======================================================= BALANCE SHEET VIEW ====================================================================

+ Current Assets
    + Vikas
    + Neha
        + GST         90000
            - CGST  - 30000
            - SGST  - 40000



===================================================== VUE CDN EXAMPLE ===========================================

new Vue({
    el: '#app',
    data: {
    },
    created: {
    },
    methods: {
    },
    mounted: {
    }
});







\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
CASE 1:
========

Current Assets
    + Sundry Debitors(30000)
        -> Vikas (Legder)  -- (30000)

            + Vikas(2700)
                --> Input SGST -- (2700)

                    + Vikas 1(-20000)
                        -> Dena Bank -- (-20000)

                            + Vikas 2(62600)
                                + Misc Assets(62600)
                                    -> Cash Account -- (62600)

    + Tax(2700)
        + GST(2700)
            + Payable Tax(2700)
                --> Input CGST -- (2700)




CASE 2:
=======

Current Assets (78000)
    + Sundry Debitors(75300)
        -> Vikas (Legder)  -- (30000)

            + Vikas(45300)
                --> Input SGST -- (2700)

                    + Vikas 1(42600)
                        -> Dena Bank -- (-20000)

                            + Vikas 2(62600)
                                + Misc Assets(62600)
                                    -> Cash Account -- (62600)

    + Tax(2700)
\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\




CASE 1:
========

Current Assets
    + Sundry Debitors(30000)
        -> Vikas (Legder)  -- (30000)

            + Vikas(2700)
                --> Input SGST -- (2700)

                    + Vikas 1(-20000)
                        -> Dena Bank -- (-20000)

                            + Vikas 2(62600)
                                + Misc Assets(62600)
                                    -> Cash Account -- (62600)

    + Tax(2700)
        + GST(2700)
            + Payable Tax(2700)
                --> Input CGST -- (2700)


CASE 2:
=======

Current Assets (78000)
    + Sundry Debitors(75300)
        -> Vikas (Legder)  -- (30000)

            + Vikas(45300)
                --> Input SGST -- (2700)

                    + Vikas 1(42600)
                        -> Dena Bank -- (-20000)

                            + Vikas 2(62600)
                                + Misc Assets(62600)
                                    -> Cash Account -- (62600)

    + Tax(2700)
        + GST(2700)
            + Payable Tax(2700)
                --> Input CGST -- (2700)






Current Assest
→ Sundry Debtors
→→ Vikas
→→→ Vikas 1
→→→→ Vikas 2
→→→→→ Misc Assets
→ Input Sgst
→ Gst Input
→ Tax
→→ Gst
→→→ Payable Tax
→→→→ Input Cgst




Current Assest: [
    {
        Sundry Debtors: [Vikas,    Vikas 1,    Vikas 2,    Misc Assets]
    },
    {
        "Input Sgst": []
    },
    {
        "Tax": [Gst, Payable Tax, Input Cgst]
    }
]



→ Sundry Debtors
→→ Vikas
→→→ Vikas 1
→→→→ Vikas 2
→→→→→ Misc Assets
→ Input Sgst
→ Gst Input
→ Tax
→→ Gst
→→→ Payable Tax
→→→→ Input Cgst




1. Misc Assets (62600)
2. Vikas 2(62600)
3. Vikas 1(42600)



1. add dict in the order position, like if "Misc Assets" add it to 5th position.
2. take the grops from bottom, even if it does not have sub grp or ledgers.
3. loop over the given dict and show the data.
4. add dummy data and try on ui.
5. try below json as an api in vue, if that works then create array if that.
6. first try the counter increment in vue js, consider below code:
        <template>
        <div>
            <div v-for="(counter, index) in counters" :key="index">
            <p>Counter {{ index + 1 }}: {{ cumulativeCounter(index) }}</p>
            </div>
        </div>
        </template>

        <script>
        export default {
            data() {
                return {
                counters: [20, 30, 40]  // Example counter values, replace with your API data
                };
            },
            methods: {
                cumulativeCounter(index) {
                let sum = 0;
                for (let i = 0; i <= index; i++) {
                    sum += this.counters[i];
                }
                return sum;
                }
            }
        };
        </script>



bkp:

[
    grp1: [
        "Input Cgst": 0, "ledger": [],
        "Payable Tax": 2700, "ledger": ["Input Cgst"],
        "Gst": 0, "ledger": [],             # add here
        "Tax": 0, "ledger": [],
    ],
    grp2: [
        "Gst Input": 0, "ledger": [],
    ],
    grp3: [
        "Input Sgst": 0, "ledger": [],
    ],
    grp3: [
        "Misc Assets": 62600, "ledger": ['Cash Account'],
        "Vikas 2": 62600, "ledger": [],
        "Vikas 1": -20000, "ledger": ['Dena Bank '],             # do addition here above all amt + this amt
        "Vikas": 2700, "ledger": ['Input SGST'],
        "Sundry Debtors": 30000, "ledger": ['Vikas (Legder)'],
    ],
]




Current Assest
→ Sundry Debtors
→→ Vikas
→→→ Vikas 1
→→→→ Vikas 2
→→→→→ Misc Assets
→ Input Sgst
→ Gst Input
→ Tax
→→ Gst
→→→ Payable Tax
→→→→ Input Cgst




const grp1 = {
            "Tax": {
                "amt": 0,
                "Gst": {
                    "amt": 0,
                    "Payable Tax": {
                        "amt": 2700,
                    }
                }
            }
        };


const grp1 = {
            "Tax": {
                "amt": 0,
                "ledger": [],
                "Gst": {
                    "amt": 0,
                    "ledger": [],
                    "Payable Tax": {
                        "amt": 2700,
                        "ledger": ["Input Cgst"]
                    }
                }
            }
        };


[
    grp1: [
        "Input Cgst": {"ledger": [{}]},
        "Payable Tax": {"ledger": [{"Input Cgst": 2700}]},
        "Gst": {"ledger": []},             # add here
        "Tax": {"ledger": []},
    ],
    grp2: [
        "Gst Input": {"ledger": []},
    ],
    grp3: [
        "Input Sgst": {"ledger": []},
    ],
    grp3: [
        "Misc Assets": {"ledger": ['Cash Account': 62600]},
        "Vikas 2": {"ledger": []},
        "Vikas 1": {"ledger": ['Dena Bank': -20000]},             # do addition here above all amt + this amt
        "Vikas": {"ledger": ['Input SGST': 2700]},
        "Sundry Debtors": {"ledger": ['Vikas (Legder)': 30000]},
    ],
]







in vue js i want to show the above ledgers_grps array in a
table every new grp array is a new group so first group will be shown as:

1. if the first elemnt of a new grp array has no amt and has no ledger dont show it on table
2. for every new row, it should show the seperate grps,
3. if there is no ledger its parent should show the ledger amt, else sum up the below ledger amt and show above
4. above group should add elemnt as patent, like first Input CGST will be added as ledger and group name will be
Payable Tax & then GST and so on

5. so for first grp1 array the table will look likw below
+ Tax(2700)
    + GST(2700)
        + Payable Tax(2700)
            --> Input CGST -- (2700)






if elemnt is first and amout is 0 and have no ledger remove from the list


+ Sundry Debtors (75300)
    * Vikas (Legder) 30000

        + Vikas (45300)
            * Input SGST (2700)

                + Vikas 1 (-20000 + 62600)(42600)
                    * Dena Bank (-20000)

                        + Vikas 2 (62600)
                            + Misc Assets (62600)
                                * Cash Account (62600)



+ Tax(2700)
    + GST (2700)
        * Input Cgst (2700)
            + Payable Tax





Sundry Debtors
    * Vikas (Legder) - 30000
        -> Vikas (30000 + 2700) - (32700)
            -> Vikas 1
                * Dena Bank (32700 - 20000) ()










vendor name

purchase(*stock)
sale(*stock)



calculate_running_balance*(
    Ganesh,
    total amt of stock(debit),
    None(credit),
    get from GL
)




=======================================DATATABLE WARNING IN VOUCHER CREATION=============================
It is cuz the models have new fields added for stock, change it later.


PURCHASE
from_ledger = purchases
particular = Ganesh
debit amt =



from_ledger = Ganesh
particular = purchases
credit_amt =



SALES

from_ledger = sales
particular = Ganesh
credit amt =



from_ledger = Ganesh
particular = sales
debit amt =


{
    "stocks": [
        {
            "payment_option": "",
            "quantity": "10",
            "rate": "2",
            "amount": 20,
            "stock_name": 1
        },
        {
            "payment_option": "",
            "quantity": "20",
            "rate": "3",
            "amount": 60,
            "stock_name": 3
        }
    ],
    "voucher_name": "purchase_voucher",
    "vendor_name": "1",
    "voucher_type": 1,
    "voucher_number": 1,
    "booking_date": "2024-08-08",
    "invoice_date": "2024-07-21",
    "invoice_number": "445678",
    "total_purchases": 80,
    "amount_in_words": "eighty",
    "narration": "345678"
}



{
    "stocks": [
        {
            "payment_option": "",
            "quantity": "10",
            "rate": "20",
            "amount": 200,
            "stock_name": 1
        },
        {
            "payment_option": "",
            "quantity": "20",
            "rate": "20",
            "amount": 400,
            "stock_name": 1
        }
    ],
    "voucher_name": "sale_voucher",
    "vendor_name": "24",
    "voucher_type": 2,
    "voucher_number": 1,
    "booking_date": "2024-08-01",
    "invoice_date": "2024-07-27",
    "invoice_number": "45678",
    "total_purchases": 600,
    "amount_in_words": "six hundred",
    "narration": "3456789"
}



======================================================
opening balance:
date:
from_ledger: ledger name
particular: opening balance
balance: 0



MORE ACCOUNT PENDING:
voucher number increment
adding filter in balance sheet adn p & l
opening balance is different for p & l







======================================================
against Refrence  = 1
group data = 2
add one more option in ledger to ask for against refrence




















============================= ACCOUNTS FINAL PENDING ===================================================
1. voucher number increment - Done
2. adding filter in balance sheet adn p & l( for now add in p & l only ): Done
        --> add validation for date filter, provide both from and to date
        --> to date cannot be less than from data
3. opening balance is different for p & l
4. add in ledger model if against refrence should be shown: Done
---------------- Others -----------------------
5. check if group update is working.
6. add validation in sub group too.





get all the vouchers modal created for voucher number RVM-JULY-001	and do the increment from there,
if no vouchers are there in voucher create modal then take from indexing if not there also then defaul incr.








================================ BUG FIXES IN ACCOUNTS ====================================================
1. If i have 2 purchases or more then i am getting both, which one should i take?
2. show data on eye view of purchase and sale
3. what to do on edit?
4. change counter of voucher
5. for composite entry of same ledger, getting wrong against refrences



















// Input data
const data = `
→ Tax
→→ Gst
→→→ Payable Tax
→→→→ Input Cgst
`;

// Function to convert the input data into a nested object
function convertData(input) {
    const lines = input.trim().split('\n');
    const root = {};
    let current = root;

    // Stack to keep track of the current path
    const pathStack = [{ level: 0, obj: root }];

    lines.forEach(line => {
        const levels = line.match(/→/g).length; // Count the number of arrows
        const name = line.replace(/→/g, '').trim(); // Get the name after arrows

        // Find the correct parent object from the stack
        while (pathStack.length > 0 && pathStack[pathStack.length - 1].level >= levels) {
            pathStack.pop();
        }

        const parent = pathStack[pathStack.length - 1].obj;

        // Create the new object
        parent[name] = { "amt": 0 };

        // Add the new object to the stack
        pathStack.push({ level: levels, obj: parent[name] });
    });

    return root;
}

// Convert the input data
const result = convertData(data);

// Display the result
console.log(JSON.stringify(result, null, 2));







{
  "Sundry Debtors": {
    "amt": 0,
    "Vikas": {
        ledgers: [
            {"gold" : 300000},
            {"silver" : 300000},
        ]
      "amt": 0,
      "Vikas 1": {
        "amt": 0,
        "Vikas 2": {
          "amt": 0,
          "Misc Assets": {
            "amt": 0
          }
        }
      }
    }
  },


}



{'Assets': {'Current Assets':
{
    'Sundry Debtors': {
        'Vikas': {
            'Vikas 1': {
                'Vikas 2':
                {}}}}}}}

{
  "Sundry Debtors": {
    "Vikas": {
      "Vikas 1": {
        "Vikas 2": {
          "Misc Assets": {
          }
        }
      }
    }
  },
  "Input Sgst": {
    "amt": 0
  },
  "Gst Input": {
    "amt": 0
  },
  "Tax": {
    "amt": 0,
    "Gst": {
      "amt": 0,
      "Payable Tax": {
        "amt": 0,
        "Input Cgst": {
          "amt": 0
        }
      }
    }
  }
}






{
  "Sundry Debtors": {
    "Vikas": {
      "Vikas 1": {
        "Vikas 2": {
          "Misc Assets": {
          }
        }
      }
    }
  },
  "Input Sgst": {
  },
  "Gst Input": {
  },
  "Tax": {
    "Gst": {
      "Payable Tax": {
        "Input Cgst": {
        }
      }
    }
  }
}


















childs are =============> Vikas 2
childs are =============> Vikas 1
childs are =============> Vikas
childs are =============> Sundry Debtors
childs are =============> Current Assest
childs are =============> Assets











all_childs = []
balance_sheet_childs = []
def traverse_children(investment, depth=0):
    child = 0
    if cost_center:
        children = investment.cost_center.all()
    else:
        children = investment.children.all()
    if children:
        print("Out side==============================================")
        for child in children:
            show = f"{'→'* depth} {child}"
            # show = f"{child}"
            print("childs---------->", child)
            print("childs---------->", depth)
            if balance_sheet:
                balance_sheet_childs.append(child)
            else:
                all_childs.append(show)
            traverse_children(child, depth + 1)
traverse_children(parent)
if balance_sheet:
    return balance_sheet_childs
return all_childs

in above django code i get below output:

Out side==============================================
childs----------> Sundry Debtors
childs----------> 0
Out side==============================================
childs----------> Vikas
childs----------> 1
Out side==============================================
childs----------> Vikas 1
childs----------> 2
Out side==============================================
childs----------> Vikas 2
childs----------> 3
Out side==============================================
childs----------> Misc Assets
childs----------> 4
childs----------> Input Sgst
childs----------> 0
childs----------> Gst Input
childs----------> 0
childs----------> Tax
childs----------> 0
Out side==============================================
childs----------> Gst
childs----------> 1
Out side==============================================
childs----------> Payable Tax
childs----------> 2
Out side==============================================
childs----------> Input Cgst
childs----------> 3


but instead of showing the number i want to create a nested dict, like below:



{
  "Sundry Debtors": {
    "Vikas": {
      "Vikas 1": {
        "Vikas 2": {
          "Misc Assets": {
          }
        }
      }
    }
  },
  "Input Sgst": {
  },
  "Gst Input": {
  },
  "Tax": {
    "Gst": {
      "Payable Tax": {
        "Input Cgst": {
        }
      }
    }
  }
}


















{'Sundry Debtors': {'Vikas': {'Vikas 1': {'Vikas 2': {'Misc Assets': {}}}}}, 'Input Sgst': {}, 'Gst Input': {}, 'Tax': {'Gst': {'Payable Tax': {'Input Cgst': {}}}}}



{'Capital': {'Capital Account': {}}, 'Reserve': {}, 'Loan': {}, 'Current Liabilities': {'Creditors': {}}, 'Misc Liabilities': {}, 'Subscription Towards Shares': {}, 'Reserve Fund And Other Funds': {}, 'Secured Loans': {}, 'Unsecured Loans': {}, 'Deposits': {}, 'Current Liabilities And Provisions': {'Current Liability For Ac': {}, 'Current Liability Example': {}, 'Liability Purchase': {}, 'Sundry Creditor': {'Kiran': {}}}, 'Interest Accrued Due But Not Paid': {}, 'Share Capital': {'Shares On Demand': {'Supply Shares': {}}}}


{'Direct Income': {'Maintainance': {}}, 'Indirect Income': {}}


{'Direct Expenses': {'Couriers': {}}, 'Indirect Expenses': {'Rent Account': {}, 'Salary': {}}}





<ul class="list">
        <li><a href="#" class="list-item">Current Assets</a>
          <ul class="list open" style="--depth: 2">
            <li><a href="#" class="list-item">Item 1.1</a>
              <ul class="list" style="--depth: 3">
                <li><a href="#" class="list-item">Item 1.1.1</a></li>
                <li><a href="#" class="list-item">Item 1.1.2</a>
                  <ul class="list" style="--depth: 3">
                    <li><a href="#" class="list-item">Item 1.2</a></li>
                  </ul>
                </li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>


make above code dynamic, balance_sheet code should show all the childs and parent in above list format, below code is vue js
p.s: i am using vue js cdn

balance_sheet = {
    'Sundry Debtors': {
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        },
        'Vikas': {
            'ledgers': {
                'Sam': 2000,
            },
            'Vikas 1': {
                'Vikas 2': {
                    'Misc Assets': {}
                }
            }
        }
    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}



{
    'Sundry Debtors': {
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        }
        'Vikas': {
            'Vikas 1': {
                'Vikas 2': {
                    'ledgers': {
                        'Sameer': 2500
                    }
                    'Misc Assets': {},
                }
            }
        },

    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}














Child is: Misc Assets GL OBJ IS:<QuerySet []>
Child is: Vikas 2 GL OBJ IS:<QuerySet [{'from_ledger__ledger_name': 'Sameer'}]>
Child is: Vikas 1 GL OBJ IS:<QuerySet []>
Child is: Vikas GL OBJ IS:<QuerySet []>
Child is: Sundry Debtors GL OBJ IS:<QuerySet [{'from_ledger__ledger_name': 'Ganesh'}, {'from_ledger__ledger_name': 'Web Development Charges'}]>
Child is: Input Sgst GL OBJ IS:<QuerySet []>
Child is: Gst Input GL OBJ IS:<QuerySet []>
Child is: Input Cgst GL OBJ IS:<QuerySet []>
Child is: Payable Tax GL OBJ IS:<QuerySet []>
Child is: Gst GL OBJ IS:<QuerySet []>
Child is: Tax GL OBJ IS:<QuerySet []>





{
    'Sundry Debtors': {
        'total': 14500,
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        },
        'Vikas': {
            'total': 2500,
            'Vikas 1': {
                'total': 2500,
                'Vikas 2': {
                    'total': 2500,
                    'ledgers': {
                        'Sameer': 2500
                    },
                    'Misc Assets': {}
                }
            }
        }
    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}



can we do the ledger amount total, show total in each parent group in like below:


{
    'Sundry Debtors': {
        'total': 14500,
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        },
        'Vikas': {
            'total': 2500,
            'Vikas 1': {
                'total': 2500,
                'Vikas 2': {
                    'total': 2500,
                    'ledgers': {
                        'Sameer': 2500
                    },
                    'Misc Assets': {}
                }
            }
        }
    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}














{
    'Sundry Debtors': {
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        },
        'Vikas': {
            'Vikas 1': {
                'Vikas 2': {
                    'ledgers': {
                        'Sameer': 2500
                    },
                    'Misc Assets': {}
                }
            }
        }
    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}


















Sundry Debtors
→ Vikas
→→ Vikas 1
→→→ Vikas 2
→→→→ Misc Assets
Input Sgst
Gst Input
Tax
→ Gst
→→ Payable Tax
→→→ Input Cgst



<ul class="list" :style="{ '--depth': depth }">
    <li v-for="(value, key) in data" :key="key">
        <a href="#" class="list-item">{{ key }}</a>
        <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
    </li>
</ul>



{% verbatim %}
    <ul class="list" :style="{ '--depth': depth }">
        <li v-for="(value, key) in data" :key="key">
        <a v-if="key !== 'ledgers'" href="#" class="list-item">
            {{ key }} abcd
        </a>
        <p v-if="key === 'ledgers'" v-for="(amount, ledger) in value" :key="ledger">
            {{ ledger }}: <span class="amount">{{ amount }}</span><br>
        </p>
            <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
        </li>
    </ul>
{% endverbatim %}





also i want to calculate the total of gl_obj['balance'] and send that total in as the name total_amt















{
    'ledgers': {
        'Fareen': 30000
    },
    'total_amt': 30000,
    'Sundry Debtors': {
        'ledgers': {
            'Ganesh': 2000,
            'Web Development Charges': 10000
        },
        'total_amt': 12000,
        'Vikas': {
            'Vikas 1': {
                'Vikas 2': {
                    'ledgers': {
                        'Transport Charges': 2000,
                        'Sameer': 2500
                    },
                    'total_amt': 4500,
                    'Misc Assets': {
                        'ledgers': {
                            'GST': 10000
                        },
                        'total_amt': 10000
                    }
                }
            }
        }
    },
    'Input Sgst': {},
    'Gst Input': {},
    'Tax': {
        'Gst': {
            'Payable Tax': {
                'Input Cgst': {}
            }
        }
    }
}





'Vikas 2': {
    'final_total': 14500,
    'ledgers': {
        'Transport Charges': 2000,
        'Sameer': 2500
    },
    'Misc Assets': {
        'final_total': 10000,
        'ledgers': {
            'GST': 10000
        },
    },
},

















<ul class="list" :style="{ '--depth': depth }">
    <li v-for="(value, key) in data" :key="key">
        <a v-if="key !== 'ledgers' && key !== 'final_total'" href="#" class="list-item">
            {{ key }}: <span class="amount">{{ value.final_total }}</span>
        </a>
        <p v-if="key === 'ledgers'" v-for="(amount, ledger) in value" :key="ledger">
            {{ ledger }}: <span class="amount">{{ amount }}</span><br>
        </p>
        <nested-list v-if="isObject(value) && key !== 'ledgers' && key !== 'final_total'" :data="value" :depth="depth + 1"></nested-list>
    </li>
</ul>




<ul class="list" :style="{ '--depth': depth }">
    <li v-for="(value, key) in data" :key="key">
      <a v-if="key !== 'ledgers' && key !== 'final_total'" href="#" class="list-item">
        {{ key }} ----
      </a>
      <p v-if="key === 'ledgers'" v-for="(amount, ledger) in value" :key="ledger">
        {{ ledger }}: <span class="amount">{{ amount }}</span><br>
      </p>
      <nested-list v-if="isObject(value) && key !== 'final_total'" :data="value" :depth="depth + 1"></nested-list>
      <p v-if="key === 'final_total'" class="final-total">
        {{ 'final_total: ' + value }}
      </p>
    </li>
  </ul>








  # FINAL WORKING:

  <ul class="list" :style="{ '--depth': depth }">
    <li v-for="(value, key) in data" :key="key" v-if="key !== 'final_total'">
    <a v-if="key !== 'ledgers'" href="#" class="list-item">
        {{ key }} ---- <span class="amount">{{ value.final_total !== undefined ? value.final_total : 0 }}</span>
    </a>
    <p v-if="key === 'ledgers'" v-for="(amount, ledger) in value" :key="ledger">
        {{ ledger }}: <span class="amount">{{ amount }}</span><br>
    </p>
    <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
    </li>
</ul>

































BKP CODE:




{% extends 'base.html' %}
{% load static %}

{% block title %} <title>Society Management | Member-Master-Creation</title> {% endblock title %}

{% block body %}

<style>
    :root {
        --color-theme-rgb: 40, 40, 40;
        --color-text-rgb: 250, 250, 250;
        --color-primary-rgb: 80, 110, 120;
        --color-box-rgb: 30, 30, 30;
      }
      * {
        box-sizing: border-box;
      }
      a {
        color: inherit;
        text-decoration: none;
      }

      aside {
        width: 250px;
        padding: 1em 0;
        flex-shrink: 0;
        flex-basis: 250px;
      }

      aside .list,
      aside .list-item {
        display: block;
        padding: 0;
        margin: 0;
      }
      aside .list {
        --depth: 1;
      }
      aside .list-item {
        padding: 0.5em 1em 0.5em calc(2em * var(--depth));
        margin: 0 0 3px 0;
        display: flex;
        align-items: center;
        position: relative;
      }
      aside .list-item:hover,
      aside .list li:has(.list-item.active) > .list-item,
      aside .list-item.active {
        background-color: rgb(var(--color-primary-rgb));
        border-top-right-radius: 999px;
        border-bottom-right-radius: 999px;
        cursor: pointer;
      }
      aside .list-item:has(+ .list)::before {
        content: '';
        display: block;
        position: absolute;
        margin-left: -1.15em;
        width: 0.3em;
        height: 0.3em;
        border-width: 0 1px 1px 0;
        border-style: solid;
        transform: rotate(-45deg);
        transition: transform 300ms;
      }

      .list .list {
        overflow-y: hidden;
        height: 0;
      }
      .list .list.open {
        height: auto;
      }
      .list .list-item:has(+ .list.open)::before {
        transform: rotate(45deg);
      }

      #main {
        display: block;
        padding: 0.5em 1em;
        min-width: 500px;
        max-width: calc(100% - 250px);
        flex-grow: 1;
      }
      .box {
        display: block;
        max-width: 300px;
        margin: 0 auto;
        padding: 0.5em 1em;
        background-color: rgb(var(--color-box-rgb));
      }
</style>


{% verbatim %}
<div class="container-fluid mt-5">
  <div class="row">
    <div class="col-lg-6" style="font-size: 21px;" id="app">
      <nested-list :data="balance_sheet2" :depth="1"></nested-list>
    </div>
  </div>
</div>
{% endverbatim %}




<script>
    const collapse = function(willCollapse = true, callback = (list) => {}) {
        this.collapsing = true;
        const height = this.scrollHeight;
        const stateFrom = {height: height + 'px'};
        const stateTo = {height: '0px'};

        let animateState = [stateFrom, stateTo];
        if(!willCollapse) animateState = [stateTo, stateFrom];

        this.animate(animateState,{
          duration:500,
          iterations:1,
          easing:'ease-in-out'
        }).finished.then(val => {
          this.collapsing = false;
          if(callback && typeof(callback) == 'function'){
            callback(this);
          }
        });
      }
      const showActiveTab = (tab) => {
        if(tab){
          document.querySelector('#active-tab').textContent = tab.textContent;
        }
      }
      showActiveTab(document.querySelector('.list-item.active'));

      document.querySelectorAll('.list li').forEach(li => {
          const list = li.querySelector('.list');
          if(list)list.collapse = collapse.bind(list);
          li.querySelector('.list-item').addEventListener('click', (event) => {
              // if not a list (just list-item)
              if(!list){
                document.querySelectorAll('.list-item').forEach(listItem => {
                  listItem.classList.remove('active');
                });
                event.target.classList.add('active');
                showActiveTab(event.target);
                event.preventDefault();
                return;
              }
              // if list still collapsing
              if(list.collapsing){
                  event.preventDefault();
                  return;
              }
              // set list collapse or open
              if(!list.classList.contains('open')) {
                  list.classList.add('open')
                  list.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                  list.parentElement.parentElement.querySelectorAll('& > li > .list.open').forEach(oList => {
                    if(oList !== list){
                      oList.collapse(true, ls => {
                          ls.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                          ls.classList.remove('open');
                      });
                    }
                  });
                  // open
                  list.collapse(false);
              } else {
                  // collapse
                  list.collapse(true, ls => {
                      ls.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                      ls.classList.remove('open');
                  });
              }
          })
      })
</script>

<script>
  Vue.component('nested-list', {
      props: ['data', 'depth'],
      template: `
      {% verbatim %}
      <ul class="list row" :style="{ '--depth': depth }">
        <li v-for="(value, key) in data" :key="key" v-if="key !== 'final_total'" class="col-12">
          <div class="row">
            <div class="col-md-3 text-start">
              {{ key !== 'ledgers' ? (value.final_total !== undefined ? value.final_total.toLocaleString() : '0') : '' }}
            </div>
            <div class="col-md-3">
              <a v-if="key !== 'ledgers'" href="#" class="list-item">
                <span>{{ key }}</span>
              </a>
              <template v-if="key === 'ledgers'">
                <p v-if="Object.keys(value).length > 0" v-for="(amount, ledger) in value" :key="ledger">
                  {{ ledger }}: <span class="amount">{{ amount }}</span><br>
                </p>
              </template>
            </div>
            <div class="col-md-3 text-end">
              {{ key !== 'ledgers' ? (value.final_total !== undefined ? value.final_total.toLocaleString() : '0') : '' }}
            </div>
            <div class="col-md-3 text-end">
              {{ key !== 'ledgers' ? (value.final_total !== undefined ? value.final_total.toLocaleString() : '0') : '' }}
            </div>
          </div>
          <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
        </li>
      </ul>
      {% endverbatim %}
      `,
      methods: {
          isObject(value) {
              return value && typeof value === 'object';
          },
          initializeCollapse() {
            // Your existing JavaScript code
            const collapse = function(willCollapse = true, callback = (list) => {}) {
              this.collapsing = true;
              const height = this.scrollHeight;
              const stateFrom = {height: height + 'px'};
              const stateTo = {height: '0px'};

              let animateState = [stateFrom, stateTo];
              if (!willCollapse) animateState = [stateTo, stateFrom];

              this.animate(animateState, {
                duration: 500,
                iterations: 1,
                easing: 'ease-in-out'
              }).finished.then(val => {
                this.collapsing = false;
                if (callback && typeof(callback) == 'function') {
                  callback(this);
                }
              });
            };
            const showActiveTab = (tab) => {
              if (tab) {
                document.querySelector('#active-tab').textContent = tab.textContent;
              }
            };
            showActiveTab(document.querySelector('.list-item.active'));

            document.querySelectorAll('.list li').forEach(li => {
              const list = li.querySelector('.list');
              if (list) list.collapse = collapse.bind(list);
              li.querySelector('.list-item').addEventListener('click', (event) => {
                // if not a list (just list-item)
                if (!list) {
                  document.querySelectorAll('.list-item').forEach(listItem => {
                    listItem.classList.remove('active');
                  });
                  event.target.classList.add('active');
                  showActiveTab(event.target);
                  event.preventDefault();
                  return;
                }
                // if list still collapsing
                if (list.collapsing) {
                  event.preventDefault();
                  return;
                }
                // set list collapse or open
                if (!list.classList.contains('open')) {
                  list.classList.add('open');
                  list.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                  list.parentElement.parentElement.querySelectorAll('& > li > .list.open').forEach(oList => {
                    if (oList !== list) {
                      oList.collapse(true, ls => {
                        ls.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                        ls.classList.remove('open');
                      });
                    }
                  });
                  // open
                  list.collapse(false);
                } else {
                  // collapse
                  list.collapse(true, ls => {
                    ls.querySelectorAll('.list').forEach(oList => oList.classList.remove('open'));
                    ls.classList.remove('open');
                  });
                }
              });
            });
          },
      },
    mounted() {
      this.initializeCollapse();
    },
    updated() {
      this.initializeCollapse();
    }
  });

  new Vue({
      el: '#app',
      data: {
        // balance_sheet2: {},
        balance_sheet2: {'Fixed Assets': {'Sold': {}, 'Furniture': {}, 'Computer Asset': {'ledgers': {'Sam': 16000}, 'Sales Computer': {}}, 'Cars': {'Super Cars': {}}}, 'Investment': {}, 'Current Assest': {'ledgers': {'Fareen': 30000}, 'Sundry Debtors': {'ledgers': {'Ganesh': 2000, 'Web Development Charges': 10000}, 'Vikas': {'Vikas 1': {'Vikas 2': {'ledgers': {'Transport Charges': 2000, 'Sameer': 2500}, 'Misc Assets': {'ledgers': {'GST': 10000}}}}}}, 'Input Sgst': {}, 'Gst Input': {}, 'Tax': {'Gst': {'Payable Tax': {'Input Cgst': {}}}}}, 'Gold': {'Mixed Gold': {}}, 'Silver': {'Pure Silver': {'Pure Gold': {'Pg': {}}}, 'Mixed Silver': {}}, 'Iron': {}, 'Cash And Bank Balances': {'Cash Account': {}, 'Bank Current Account': {}, 'Cash In Hand': {}}, 'Loans And Advances': {}, 'Profit And Loss Account': {}}

        },
      mounted(){
        axios.get('http://127.0.0.1:8000/api/balance_sheet')
        .then(response => {
          this.balance_sheet2 = response.data['assets_response'][0];
          console.log("response is================", this.balance_sheet2);
        })
        .catch(error => {
          console.log("Error Fetching Balance Sheet Data.")
        });
      }
  });
</script>

{% endblock body %}




























def calling_balance_sheet(request):
    assets_response = []
    liabilities_response = []
    groups = ['Assets', 'Liabilities']
    for grp in groups:
        function_call = balance_sheet_groups(Childs.objects.get(name=grp))
        liabilities_response.append(function_call)
        if grp == 'Assets':
            assets_response.append(function_call)
        print("calling grp=============", function_call)
    return JsonResponse({'assets_response': assets_response, 'libility_response': liabilities_response})


def balance_sheet_groups(parent, cost_center=False):
    def traverse_children(investment):
        def helper(node):
            ledgers_dict = {}
            children_dict = {}
            total_balance = 0

            gl_objs = GeneralLedger.objects.filter(from_ledger__group_name=node.name)
            for gl_obj in gl_objs.values('from_ledger__ledger_name', 'balance'):
                ledgers_dict[gl_obj['from_ledger__ledger_name']] = gl_obj['balance']

            children = node.cost_center.all() if hasattr(node, 'cost_center') else node.children.all()

            # Process children nodes
            for child in children:
                child_result, child_total = helper(child)
                children_dict[child.name] = child_result
                total_balance += child_total  # Add the child's total balance to the parent's total balance

            # Combine ledgers and children dictionaries
            result_dict = {}
            if ledgers_dict:
                result_dict['ledgers'] = ledgers_dict
            result_dict.update(children_dict)
            result_dict['final_total'] = total_balance  # Add the total balance to the result_dict

            return result_dict, total_balance

        # Start the recursion from the investment node
        final_result, _ = helper(investment)
        return final_result

    nested_dict = traverse_children(parent)
    return nested_dict




FALTU WALA CODE:

# # BKP TRIAL
# def get_all_child_investments(parent, cost_center=False, balance_sheet=False):
#     all_childs = []
#     balance_sheet_childs = []
#     def traverse_children(investment):
#         def helper(node):
#             # Initialize dictionaries for ledgers and children
#             ledgers_dict = {}
#             children_dict = {}

#             # Retrieve ledgers related to the current node
#             gl_objs = GeneralLedger.objects.filter(from_ledger__group_name=node.name)
#             for gl_obj in gl_objs.values('from_ledger__ledger_name', 'balance'):
#                 ledgers_dict[gl_obj['from_ledger__ledger_name']] = gl_obj['balance']

#             # Retrieve children of the current node
#             children = node.cost_center.all() if cost_center else node.children.all()

#             # Process children nodes
#             for child in children:
#                 children_dict[child.name] = helper(child)

#             # Combine ledgers and children dictionaries
#             result_dict = {}
#             if ledgers_dict:
#                 result_dict['ledgers'] = ledgers_dict
#             result_dict.update(children_dict)

#             return result_dict

#         result = helper(investment)
#         return result

#     nested_dict = traverse_children(parent)
#     print(nested_dict)

#     if balance_sheet:
#         return balance_sheet_childs
#     return all_childs

































def balance_sheet_groups(parent, filter_zero, from_date, to_date):
    def traverse_children(investment):
        def helper(node):
            ledgers_dict = {}
            children_dict = {}
            total_balance = 0

            subquery = GeneralLedger.objects.filter(from_ledger__group_name=node.name).values('from_ledger__ledger_name').annotate(max_id=Max('id')).values('max_id')
            gl_objs = GeneralLedger.objects.filter(id__in=Subquery(subquery))

            if from_date and to_date:
                gl_objs = gl_objs.filter(date__range=(from_date, to_date))

            # uncomment below code if required just both the dates
            # elif from_date:
            #     gl_objs = gl_objs.filter(date__gte=from_date)
            # elif to_date:
            #     gl_objs = gl_objs.filter(date__lte=to_date)

            for gl_obj in gl_objs.values('from_ledger__ledger_name', 'balance'):
                ledger_name = gl_obj['from_ledger__ledger_name']
                balance = gl_obj['balance']
                ledgers_dict[ledger_name] = balance
                total_balance += balance  # Accumulate the total balance

            children = node.cost_center.all() if hasattr(node, 'cost_center') else node.children.all()

            for child in children:
                child_result, child_total = helper(child)
                if filter_zero == 'all':
                    children_dict[child.name] = child_result
                    total_balance += child_total
                elif filter_zero == 'zero':
                    if child_total > 0:
                        children_dict[child.name] = child_result
                        total_balance += child_total
                else:
                    children_dict[child.name] = child_result
                    total_balance += child_total

            result_dict = {}
            if ledgers_dict:
                result_dict['ledgers'] = ledgers_dict
            result_dict.update(children_dict)
            result_dict['final_total'] = total_balance  # Add the total balance to the result_dict

            return result_dict, total_balance

        final_result, _ = helper(investment)
        return final_result

    nested_dict = traverse_children(parent)

    return nested_dict





--------------------------------------- PENDING ACCOUNTING ----------------------------------------------
1. give validation when a ledger named 'ledger' is added in ledger creation, cuz i have applied condition in balance sheet.
2.





----------------------- QUESTION -----------------------------
current and previous year in balanace sheet.

















from datetime import date

start_date = date(2024, 07, 04)
end_date = date(2024, 07, 31)

# Query within this date range
ledgers = GL.objects.filter(date__range=('2024-06-01', '2024-07-01'))
print("Date Range Query Results:")
print(ledgers)



broad_start_date = date(2023, 4, 1)
broad_end_date = date(2024, 3, 31)


broad_start_date = date(2023, 4, 1)
broad_end_date = date(2024, 3, 31)


ledgers_broad = GL.objects.filter(date__range=(broad_start_date, broad_end_date)).values('date', 'from_ledger__ledger_name', 'balance')
print(ledgers_broad)



broad_start_date = date(2022, 4, 1)
broad_end_date = date(2023, 3, 31)


GL.objects.filter(date__range=(broad_start_date, broad_end_date))














================================ BKP CODE OF BALANCE SHEET VUE JS ===========================================================
{% verbatim %}
      <ul class="list row" :style="{ '--depth': depth }">
        <li v-for="(value, key) in data" :key="key" v-if="key !== 'final_total' && key !== 'previous_final_total'" class="col-12">
          <div class="row">
            <div class="col-md-3 text-left">
              {{ key !== 'ledgers' ? (key === 'Previous_Total' ? data[key].toLocaleString() : (value.previous_final_total !== undefined ? value.previous_final_total.toLocaleString() : '0')) : '' }}
            </div>

            <div class="col-md-3">
              <a v-if="key !== 'ledgers'" href="#" class="list-item">
                <span>{{ key }}</span>
              </a>
              <template v-if="key === 'ledgers'">
                <p v-if="Object.keys(value).length > 0" v-for="(amount, ledger) in value" :key="ledger">
                  {{ ledger }}:
                </p>
              </template>
            </div>

            <div class="col-md-3 text-end">
              <template v-if="key === 'ledgers'">
                <p v-if="Object.keys(value).length > 0" v-for="(amount, ledger) in value" :key="ledger">
                  <span class="amount">{{ amount }}</span><br>
                </p>
              </template>
            </div>

            <div class="col-md-3 text-end">
              {{ key !== 'ledgers' ? (key === 'Total' ? data[key].toLocaleString() : (value.final_total !== undefined ? value.final_total.toLocaleString() : '0')) : '' }}
            </div>
          </div>
          <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
        </li>
      </ul>

      {% endverbatim %}












BKP CODE:

{% verbatim %}
<ul class="list row" :style="{ '--depth': depth }">
  <li v-for="(value, key, index) in data" :key="key" v-if="key !== 'final_total' && key !== 'previous_final_total'"  class="col-12">
    <div class="row">
      <div class="col-md-3 text-start">
        {{ key !== 'ledgers' ? (value.final_total !== undefined ? value.final_total.toLocaleString() : '0') : '' }}
      </div>

      <div class="col-md-3">
        <a v-if="key !== 'ledgers'" href="#" class="list-item">
          <span class="toggle-icon">+</span>
          <span :style="{fontWeight: value.parent_group ? 'bold' : 'normal', fontSize: value.parent_group ? '18px' : 'inherit'}">{{ key }}</span>
        </a>
        <template v-if="key === 'ledgers'">
          <p v-if="Object.keys(value).length > 0" v-for="(amount, ledger) in value" :key="ledger" class="view-label" style="font-style: italic;">
            {{ ledger }}:
          </p>
        </template>
      </div>

      <div class="col-md-3 text-end">
        <template v-if="key === 'ledgers'">
          <p v-if="Object.keys(value).length > 0" v-for="(amount, ledger) in value" :key="ledger">
            <span class="amount view-label" style="font-style: italic; margin-left: auto !important;">{{ amount }}</span><br>
          </p>
        </template>
      </div>

      <div class="col-md-3 text-end">
        <span :style="{
          fontWeight: value.parent_group ? 'bold' : 'normal',
          fontSize: value.parent_group ? '18px' : 'inherit'
        }">
          {{ key !== 'ledgers'
            ? (value.final_total !== undefined
                ? value.final_total.toLocaleString()
                : '0')
            : ''
          }}
        </span>
      </div>

    </div>
    <nested-list v-if="isObject(value)" :data="value" :depth="depth + 1"></nested-list>
  </li>
</ul>
{% endverbatim %}
























for below json:



{
    "related_ledgers": [
        {
            "payment_option": "dr",
            "debit_amt": "2000",
            "ledger_name": 1,
            "against_refrence": [
                {
                    "voucher_number": "RVM-JULY-001",
                    "voucher_date": "2024-09-05",
                    "pending_amt": 900,
                    "final_amt": 1000,
                    "allocated_amt": "200"
                }
            ],
            "cost_center": []
        },
        {
            "payment_option": "cr",
            "credit_amt": "3000",
            "ledger_name": 13,
            "against_refrence": [],
            "cost_center": []
        },
        {
            "payment_option": "dr",
            "debit_amt": "1000",
            "ledger_name": 1,
            "against_refrence": [
                {
                    "voucher_number": "RVM-JULY-001",
                    "voucher_date": "2024-09-05",
                    "pending_amt": 700,
                    "final_amt": 1000,
                    "allocated_amt": 200
                }
            ],
            "cost_center": []
        }
    ],
    "voucher_name": "receipt_voucher",
    "voucher_type": 9,
    "voucher_number": "RVM-JULY-002",
    "booking_date": "2024-08-30",
    "prefix": "RVM-JULY-",
    "suffix": "002",
    "debit_total": 3000,
    "credit_total": 3000,
    "amount_in_words": "three thousand",
    "voucher_date": "2024-08-30",
    "narration": "55",
    "cheque_number": "55",
    "cheque_date": "2024-08-15",
    "bank_name": "55"
}


why my below django code,  my object for ledger_name is saving the against refrence which has pending  amt 900 and the last one which has pending
amt 700 is getting saved both? it should save related ledger which has pending amt  900 with ledger name 1, which is my first object and last against refrence with ledger name as 1 with pending amt as 700

@transaction.atomic
    def create(self, request, *args, **kwargs):
        # Step 1: Save the main voucher data
        voucher_serializer = self.get_serializer(data=request.data)
        voucher_serializer.is_valid(raise_exception=True)
        voucher = voucher_serializer.save()

        # Step 2: Save related ledgers
        related_ledgers_data = request.data.get('related_ledgers', [])
        for ledger_data in related_ledgers_data:
            print("related legder is>-----------", ledger_data)
            ledger_data['voucher_type'] = voucher.id  # Link the voucher
            ledger_serializer = RelatedLedgersSerializers(data=ledger_data)
            if ledger_serializer.is_valid():
                related_ledger = ledger_serializer.save()
            else:
                return Response(ledger_serializer.errors, status=status.HTTP_400_BAD_REQUEST)


            # Step 3: Save against refrence
            against_refrence_data = ledger_data.get('against_refrence', [])
            for against_refrence in against_refrence_data:
                print("against refrence object ------------------>", against_refrence)
                against_refrence['voucher_type'] = voucher.id  # Link the related ledger
                against_refrence['against_related_ledger'] = related_ledger.id  # Link the related ledger
                against_refrence_serializer = AgainstRefrenceSerializers(data=against_refrence)
                if against_refrence_serializer.is_valid():
                    against_refrence_serializer.save()
                else:
                    return Response(against_refrence_serializer.errors, status=status.HTTP_400_BAD_REQUEST)








============================================= Pending Accounts ===============================================
1. One ledger marked important fileds done. add 2 ledgers from signals which is purchase and sale with opening balance as 0.
2. When deleting the childs not deleting the ledger, make childs as foreign key.
3. The under group i am creating, take that from constants.
4. add validation in update group.
5. new table of ledgers
6. search this is views.py of societyapp "Give these in signals as constants"


================= Question =========================
1. What are groups in p & l.
2. Which fields needs to be add as mendatory in ledger master.
3. Any predefined ledgers need to be create.
4. Ask for filters in ledgers and p an l.
5. What is those accumaleted groups in balance sheet